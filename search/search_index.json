{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"challenge/","title":"Challenge","text":"<p>Zeeds Exercise #1</p> <p>We at Zeeds use the following technologies (ordered by importance). Items marked with an asterix (*) can change in the future.</p> <ul> <li>Typescript</li> <li>React Native</li> <li>React</li> <li>GraphQL</li> <li>PostgreSQL</li> <li>Hasura</li> <li>Firebase*</li> <li>Docker</li> </ul> <p>You will need to be somewhat familiar with all of these items in order to complete this task.</p>"},{"location":"challenge/#the-challenge","title":"The Challenge","text":""},{"location":"challenge/#description","title":"Description","text":"<p>This exercise has three major parts, the app, backend and portal. The app has to be able to compile and run on both iOS and Android. You are expected to produce an app for both iOS and Android via Expo. You can read more about it here. The app should be able to run on both iOS and Android and the code should be written in Typescript. The output package should be provided to us in a zip file so that we can test it on our own simulators.</p> <p>The second part involves creating a backend with the help of Firebase and Hasura in order to handle requests and store data that gets transmitted between the app and the portal. Since Hasura is an intermediary service you will have to use some kind of database for the actual data storage, for this you will use PostgreSQL. In order to showcase your knowledge with Docker containers, we recommend that you use Docker to run the Hasura and Postgres services. You can read more about Docker here. Both Hasura nad Postgres have official Docker images that you can use. For the cloud functions, you can use Firebase's own cloud functions. You can read more about them here. The easiest way to setup Firebase is to use the Firebase CLI. You can read more about it here.</p> <p>The portal is the last part of the exercise, and it involves creating a web page by using React. API communication to Hasura happens via GraphQL and not REST. REST communication is allowed when communicating with Firebase as Firebase will only be used for authentication purposes. Remember that all the code is typed in Typescript.</p>"},{"location":"challenge/#expectations","title":"Expectations","text":"<p>You are expected to create an app that requires a user to log in. Once the user has logged in, the user arrives at a screen that has three bottom tabs. The default tab should be the middle one. In the middle tab there should be centered text called \"My favorite number\" and the user's favorite number. Initially there will not be one, so the app will prompt the user to enter one. The middle tab should also have a button called \"Update\" where when clicked, the user can update their favorite number. The tab to the left displays the user's favorite number but does not have the functionality to update it. The same for the tab to the right. </p> <p>It is expected from you to have at least three seperate repositories, one for the app, one for the portal and one for the backend. When submitting your solution, please provide us with the links to the repositories as well as instructions on how to run the app and the portal.</p> <p>The final app should be published on Expo and it should be runnable on both iOS and Android.</p> <p>Any updates the user makes have to be stored on the Postgres database. You are expected to interact with the Postgres database via Hasura as a middle-man and perform these updates via only GraphQL requests (hint: use mutations).</p> <p>You are expected to build a website that also has a login screen where the user logs in and can view their favorite number.</p>"},{"location":"challenge/#grading","title":"Grading","text":"<p>The factors that will be taken in consideration when evaluation your final result are:</p> <ul> <li>the usage of Typescript (code quality, reusability and simplicity)</li> <li>the usage of Hasura (integration with aforementioned systems as well as correct integration with Postgres database)</li> <li>proper usage of React hooks by not creating unnecessary re-renders</li> <li>usage of Expo (proper building and compiling on both platforms)</li> <li>clear instructions on how to run the app and the portal. If we cannot reproduce the environment that you've described, we unfortunately cannot grade your solution.</li> </ul>"},{"location":"onboarding/","title":"Onboarding new developers","text":"<p>A full-stack developer needs to get familiar with three systems used in the Zeeds ecosystem.</p> <ul> <li>Psychologist portal</li> <li>Cloud functions</li> <li>Mobile application</li> </ul> <p>Start by installing the docker hasura repository</p>"},{"location":"onboarding/#psychologist-portal","title":"Psychologist portal","text":"<p>The relevant repository.  Clone the repository and navigate to it. </p> <p>Description of the project structure </p>"},{"location":"onboarding/#files-at-the-root-of-the-project","title":"Files at the root of the project","text":"<ul> <li>netlify.toml - This file is used to configure your project for deployment to Netlify. It contains information about your project's name, build commands, and environment variables.</li> <li>Dockerfile - This file is used to build a Docker image for your project. It contains the instructions that Docker will use to create the image, such as the operating system, packages, and files that will be included in the image.</li> <li>craco.config.js - This file is used to configure CRACO, a tool that helps you customize the build process for your React project. It contains options for things like code splitting, bundling, and minification.</li> <li>.firebaserc - This file is used to configure your project for deployment to Firebase. It contains information about your Firebase project's name, region, and authentication credentials.</li> <li>cypress.config.js - This file is used to configure Cypress, a testing framework for React. It contains options for things like test suites, plugins, and reporters.</li> <li>README.md - This file is a Markdown file that contains a description of your project. It is often used to provide instructions on how to install, run, and test your project.</li> <li>.dockerignore - This file is used to specify files that should be excluded from the Docker image that is built for your project. This can be helpful for things like temporary files or files that are not needed for production.</li> <li>.gitignore - This file is used to specify files that should be ignored by Git. This can be helpful for things like binary files or files that are not part of your project's source code.</li> <li>package-lock.json - This file is a lock file that contains the exact versions of all of the packages that are installed in your project. This can be helpful for reproducibility and preventing conflicts when you share your project with others.</li> <li>package.json - This file is a manifest file that contains information about your project, such as its name, version, dependencies, and scripts.</li> <li>global.d.ts - This file is a declaration file that contains type information for global variables and functions. This can be helpful for things like using third-party libraries that export global variables or functions.</li> <li>tsconfig.json - This file is a configuration file that tells TypeScript how to compile your code. It contains options for things like the target version of TypeScript, the module format, and the file extensions that are used for TypeScript files.</li> <li>docker-compose.yml - This file is used to define a multi-container Docker application. It contains information about the containers that will be created, the ports that they will expose, and the volumes that they will share.</li> <li>.eslintignore - This file is used to specify files that should be ignored by ESLint. This can be helpful for things like binary files or files that are not part of your project's source code.</li> <li>tsconfig.path.json - This file is used to configure the path mappings for TypeScript. It can be helpful for things like resolving relative imports and locating declaration files.</li> <li>.env.example - This file is used to provide an example of the environment variables that are required by your project. It can be helpful for things like setting up your project's development environment.</li> </ul> <p>Setting up a local environment </p> <ul> <li>Install Node.js if you don't have it already.</li> <li>Install Docker if you don't have it already.</li> <li>Install VSCode if you don't have it already.</li> <li>Install Netlify CLI if you don't have it already.</li> <li>Install Cypress if you don't have it already.</li> </ul> <p>Setting up the environment variables</p> <ul> <li>Create a file named <code>.env</code> in the root directory of the project.</li> <li>Copy the contents of <code>.env.example</code> into <code>.env</code>.</li> </ul> <p>Running the project locally</p> <ul> <li>Run <code>npm install</code> to install the project dependencies.</li> <li>Run <code>npm start</code> to start the development server.</li> </ul> <p>If everything goes well, the development server should start on <code>http://localhost:3000</code>.</p>"},{"location":"onboarding/#cloud-functions","title":"Cloud functions","text":"<p>The relevant repository. Clone the repository and navigate to it.</p> <p>Description of the project structure</p>"},{"location":"onboarding/#files-at-the-root-of-the-project_1","title":"Files at the root of the project","text":"<ul> <li>Dockerfile - This file is used to build a Docker image for your project. It contains the instructions that Docker will use to create the image, such as the operating system, packages, and files that will be included in the image.</li> <li>README.md - This file is a Markdown file that contains a description of your project. It is often used to provide instructions on how to install, run, and test your project.</li> <li>docker-compose-with-firebase-functions.yml - This file is used to define a multi-container Docker application. It contains information about the containers that will be created, the ports that they will expose, and the volumes that they will share.</li> <li>docker-compose.yml - This file is used to define a multi-container Docker application. It contains information about the containers that will be created, the ports that they will expose, and the volumes that they will share.</li> <li>firebase.json - This file is used to configure your project for deployment to Firebase. It contains information about your Firebase project's name, region, and authentication credentials.</li> <li>firebase_emulator_baseline - This file is used to configure your project for deployment to Firebase. It contains information about your Firebase project's name, region, and authentication credentials.</li> <li>package-lock.json - This file is a lock file that contains the exact versions of all of the packages that are installed in your project. This can be helpful for reproducibility and preventing conflicts when you share your project with others.</li> <li>package.json - This file is a manifest file that contains information about your project, such as its name, version, dependencies, and scripts.</li> <li>public - This folder is used to store static assets, such as images and fonts.</li> <li>functions - This folder is used to store the source code for your Firebase functions. It contains files that are used to configure your Firebase functions, such as the name of your functions and the region that they will be deployed to.</li> <li>hasura - This folder is used to store the source code for your Hasura GraphQL engine. It contains files that are used to configure your Hasura GraphQL engine, such as the name of your Hasura GraphQL engine and the region that it will be deployed to.</li> </ul>"},{"location":"onboarding/#files-in-the-functions-directory","title":"Files in the functions directory","text":"<ul> <li>README.md - This file is a Markdown file that contains a description of your project. It is often used to provide instructions on how to install, run, and test your project.</li> <li>__tests__ - This folder is used to store the source code for your Firebase functions tests. It contains files that are used to configure your Firebase functions tests, such as the name of your functions tests and the region that they will be deployed to.</li> <li>package-lock.json - This file is a lock file that contains the exact versions of all of the packages that are installed in your project. This can be helpful for reproducibility and preventing conflicts when you share your project with others.</li> <li>package.json - This file is a manifest file that contains information about your project, such as its name, version, dependencies, and scripts.</li> <li>src - This folder is used to store the source code for your Firebase functions. It contains files that are used to configure your Firebase functions, such as the name of your functions and the region that they will be deployed to.</li> <li>tsconfig.dev.json - This file is a configuration file that tells TypeScript how to compile your code. It contains options for things like the target version of TypeScript, the module format, and the file extensions that are used for TypeScript files.</li> <li>tsconfig.json - This file is a configuration file that tells TypeScript how to compile your code. It contains options for things like the target version of TypeScript, the module format, and the file extensions that are used for TypeScript files.</li> </ul> <p>Setting up a local environment </p> <ul> <li>Install Node.js if you don't have it already.</li> <li>Install Docker if you don't have it already.</li> <li>Install VSCode if you don't have it already.</li> <li>Install Firebase CLI if you don't have it already.</li> </ul> <p>Running the project locally</p> <p>It is important to note that this repository holds 3 parts to the project: - Hasura GraphQL engine - Postgres database - Firebase functions</p> <p>To run the project locally, you need to run the following commands: - <code>docker-compose up -d</code> to start the Hasura GraphQL engine and Postgres database. - Navigate to the <code>functions</code> directory and run <code>npm install</code> to install the project dependencies for the Firebase cloud functions instance. - <code>firebase login</code> to login to your Firebase account. - <code>firebase use --add</code> to select the Firebase project that you want to use, we use the <code>staging</code> instance to select the staging environment as Firebase requires a project to deploy to but that is irrelevant in our case as all the deployment is handled via PRs and Github Actions. - <code>npm run serve</code> to start the Firebase cloud functions instance.</p> <p>If everything goes well, you should have Firebase function emulator running on your computer.</p>"},{"location":"onboarding/#testing-the-functionality-between-the-local-instances-of-the-cloud-functions-and-the-psychologist-portal","title":"Testing the functionality between the local instances of the cloud functions and the psychologist portal","text":"<p>With the local instances of the cloud functions and the psychologist portal running, you can test the functionality between them. Open your browser and open the psychologist portal on <code>http://localhost:3000</code> and the Hasura GraphQL engine on <code>http://localhost:8080/console</code>. The Hasura GraphQL engine will ask for an admin secret, you can find it in .env.example file in the root of the project. It is named <code>REACT_APP_X_HASURA_ADMIN_SECRET</code>.</p> <p>With the portal open go ahead and register a new user. You can use the following credentials:</p> <pre><code>Name - Test\nYour Email - testuser@zeeds.com\nOrganization - Zeeds\nPhone Number - 123456789\nPassword - 123456\n</code></pre> <p>After you register a new user, you should be able to see it in the Hasura GraphQL engine. To do that, go to the <code>Data</code> tab and select the <code>admin_user</code> table. You should be able to see the admin user you just registered. In order to be able to login, you need to set the <code>is_active</code> field to <code>true</code>. You can do that by clicking on the <code>Edit</code> button next to the user you just registered. After you set the <code>is_active</code> field to <code>true</code>, you should be able to login to the portal with the credentials you just registered with. The portal will send a verification code to the number you set in when you registered, but since this is a simulated environment the verification code will be printed out in the terminal where you started the Firebase cloud functions instance. You can copy the verification code from the terminal and paste it in the portal to verify your phone number. A successful verification will redirect you to the dashboard.</p>"},{"location":"onboarding/#mobile-application","title":"Mobile application","text":"<p>The relevant repository. Clone the repository and navigate to it.</p> <p>Description of the project structure</p>"},{"location":"onboarding/#files-at-the-root-of-the-project_2","title":"Files at the root of the project","text":"<ul> <li>App.tsx - This file is the main entry point for your React application. It is responsible for rendering the application's UI and handling user interactions.</li> <li>README.md - This file is a Markdown file that contains a description of your project. It is often used to provide instructions on how to install, run, and test your project.</li> <li>app.config.js - This file is used to configure the application's environment. It contains options for things like the application's port, the database connection string, and the API endpoint.</li> <li>babel.config.js - This file is used to configure Babel, a tool that helps you convert JavaScript code into a format that can be understood by older browsers. It contains options for things like the target version of JavaScript, the plugins that are used, and the presets that are applied.</li> <li>bitrise.yml - This file is used to configure Bitrise, a platform that helps you automate the build, test, and deployment of your applications. It contains information about the steps that Bitrise should take to build and deploy your application.</li> <li>codegen.ts - This file is used to generate code from a template. It can be helpful for things like creating boilerplate code or scaffolding new features.</li> <li>coverage - This directory contains the coverage reports for your project's tests. These reports can be used to identify which parts of your code are not being tested.</li> <li>defines.d.ts - This file is a declaration file that contains type information for constants and variables that are defined in your project. This can be helpful for things like using third-party libraries that export constants or variables.</li> <li>e2e - This directory contains the files that are used for end-to-end testing. End-to-end tests are used to test the entire application from the user's perspective.</li> <li>eas-hooks - This directory contains the hooks that are used to interact with the Expo App Services API. The Expo App Services API provides a way to access features like push notifications, analytics, and crash reporting.</li> <li>eas.json - This file is used to configure the Expo App Services API for your project. It contains information about the project's name, the app's ID, and the app's secret.</li> <li>graphql.config.yaml - This file is used to configure the GraphQL client for your project. It contains information about the GraphQL endpoint, the authentication credentials, and the schema.</li> <li>index.js - This file is the entry point for the application's Node.js server. It is responsible for starting the server and loading the application's code.</li> <li>metro.config.js - This file is used to configure Metro, a tool that helps you build React Native applications. It contains options for things like the project's root directory, the packager's port, and the plugins that are used.</li> <li>package-lock.json - This file is a lock file that contains the exact versions of all of the packages that are installed in your project. This can be helpful for reproducibility and preventing conflicts when you share your project with others.</li> <li>package.json - This file is a manifest file that contains information about your project, such as its name, version, dependencies, and scripts.</li> <li>src - This directory contains the source code for your project. This code can be written in JavaScript, TypeScript, or React Native.</li> <li>tsconfig.json - This file is a configuration file that tells TypeScript how to compile your code. It contains options for things like the target version of TypeScript, the module format, and the file extensions that are used for TypeScript files.</li> <li>unit_tests - This directory contains the files that are used for unit testing. Unit tests are used to test small, isolated parts of your code.</li> </ul> <p>Setting up a local environment</p> <ul> <li>Install Node.js if you don't have it already.</li> <li>Install VSCode if you don't have it already (it is the best code editor by far).</li> <li>Install Expo CLI if you don't have it already.</li> </ul> <p>Running the project locally</p> <ul> <li>Run <code>npm install</code> to install the project dependencies.</li> <li>Run <code>npm run ios</code> or <code>npm run android</code> to start the development server and open the application in the iOS or Android simulator.</li> </ul> <p>If everything goes well, you should have the application running on your computer.</p>"},{"location":"onboarding/#testing-the-functionality-between-the-local-instances-of-the-cloud-functions-and-the-mobile-application","title":"Testing the functionality between the local instances of the cloud functions and the mobile application","text":"<p>With the local instances of the cloud functions and the mobile application running, you can test the functionality between them by clicking on the login button on the mobile application. This interacts with the cloud functions and if everything is set up correctly, you should navigate to the next screen in the application. As we are running in development mode, the sign in through BankID will not be necessary and you can just click on the button to continue to the next screen, which in the background will create an anonymous user. You can view the details of that user in Hasura.</p>"},{"location":"onboarding/#publishing-a-new-version-of-the-app","title":"Publishing a new version of the app.","text":"<p>To start with you need to update the version number of the mobile repository in the package-lock.json file and the package.json file. During this you should also update the version number as it exists in the frontend code to the in animatedsplashview.tsx and profile.tsx(previously this was possible to do using the config file but that has not worked since 2.7.9). These changes should be included in the merge request for your new project. once they have been merged you pull them to the repository you are working in using the terminal and the command git pull. after that you use the command eas build --platform ios to create a new build in expo dev and then you use the eas submit --platform ios. After that the app has been updated and is ready to be released for testflight.</p>"},{"location":"onboarding/#revenuecat-integration","title":"RevenueCat integration","text":"<p>Revenuecat is a third partyy softaware used to make it easier for us to handle purchases. To create a new purchase(like a course) you first create a non-consumable in app store connect add all the values and save it then in revenuecat import the purchase to revenuecat and attach it to the correct offering and then it is usable.</p>"}]}